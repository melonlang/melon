### introduction

uwu, owo, twt, used as foo bar sort of thing. `test` is the namespace used in all code examples.

## initializing a project

todo: this

## functions

if just writing commmands in .mln file like you would in mcf

```go
time set day
```

these commands will go to the load function in your namespace (`test:load`). to create your own function use the `func` keyword. call it tick to make it run every game-tick

```go
// test:make_day
func make_day() {
  time set day
}

// this is the tick function.
func tick() {
  execute as @a run effect give @s speed 1 100 true
}
```

to create function under a specific directory, like `test:uwu/owo` we could use one of the following methods

1. dots in filename, affects the single defined function

```go
func uwu.owo() {
  time set day
}
```

2. `dir` block, affects code within the block

```go
dir uwu {
  func owo() {
    time set day
  }
}
```

3. `dir` keyword, affects code below the keyword

```go
dir uwu

func owo() {
  time set day
}
```

## variables

### compile-time variables

use `&` prefix to create a compile-time variable.

```go
// define
var &uwu str = "owo";

// use like normal variable
print(&uwu) // print() is shortcut for `tellraw @a`
// compiles to:
tellraw @a "uwu"

// or embed anywhere search-n-replace style
owo::twt&(uwu)
// is treated like
owo::twtuwu
```

### run-time variables

stored as regular values in datapacks. int (integer) type is stored via scoreboards. other types are stored in nbt format in a data storage generated by melon. melon data types pretty much copy those of [minecraft nbt format](https://minecraft.wiki/w/nbt_format) `arr` type being an exception, as it could be nbt's byte, int, or long array, as well as a list, all in one.

<details> <summary> all of the available types in melon </summary>
<br>

| type keyword | type name | storage method         |
| ------------ | --------- | ---------------------- |
| byte         | byte      | nbt storage            |
| bool         | boolean   | nbt storage            |
| short        | short     | nbt storage            |
| int          | integer   | scoreboard fake player |
| long         | long      | nbt storage            |
| float        | float     | nbt storage            |
| double       | double    | nbt storage            |
| string       | string    | nbt storage            |
| arr          | array     | nbt storage            |
| comp         | compound  | nbt storage            |

</details>

<details>
<summary>Click to expand and see the table</summary>

| Header 1     | Header 2     | Header 3     |
| ------------ | ------------ | ------------ |
| Row 1 Cell 1 | Row 1 Cell 2 | Row 1 Cell 3 |
| Row 2 Cell 1 | Row 2 Cell 2 | Row 2 Cell 3 |

</details>

```go
// define
var uwu str = "uwu"

print(uwu)
// compiles to
tellraw @a {"storage":"test:zzz", "nbt":"var.uwu"}

```

#### how it works

when you create a variable, in the compiled datapack its just setting `var.<variable_name>` to the value you give it, in the `nspace:zzz` data storage to the value you gave your variable. e.g.:

```go
var uwu str = "owo"
// compiles to:
// data modify storage namespace:zzz var.uwu set value "owo"
```

although its different when you create integer variables. it actually stores your integer in `.<var_name>` fake player in the "namespace.zzz.var" scoreboard

```go
var uwu int = 8
// compiles to:
// scoreboard players set .uwu namespace.zzz.var 8
```
